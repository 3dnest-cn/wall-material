/*!
 * @produck/geometry v0.1.0
 * (c) 2021-2023 3dnest
 * Released under the GPL-3.0 License.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
			(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["@produck/geometry"] = {}));
})(this, (function (exports) { 'use strict';

	const M = Math;

	const PI = M.PI;

	/**
	 * Radian of a circle
	 */
	const ROUND = 2 * PI;

	var Constant = /*#__PURE__*/Object.freeze({
		__proto__: null,
		PI: PI,
		ROUND: ROUND
	});

	const TUPLE$4 = [0, 0, 1, 0];

	const Tuple$4 = (anchorX, anchorY, normalX, normalY) => {
		TUPLE$4[0] = anchorX;
		TUPLE$4[1] = anchorY;
		TUPLE$4[2] = normalX;
		TUPLE$4[3] = normalY;

		return TUPLE$4;
	};

	const TUPLE$3 = [0, 0];

	const Tuple$3 = (x, y) => {
		TUPLE$3[0] = x;
		TUPLE$3[1] = y;

		return TUPLE$3;
	};

	const TUPLE$2 = [0, 0, 0, 0];

	const Tuple$2 = (fromX, fromY, toX, toY) => {
		TUPLE$2[0] = fromX;
		TUPLE$2[1] = fromY;
		TUPLE$2[2] = toX;
		TUPLE$2[3] = toY;

		return TUPLE$2;
	};

	const TUPLE$1 = [0, 0];

	const Tuple$1 = (x, y) => {
		TUPLE$1[0] = x;
		TUPLE$1[1] = y;

		return TUPLE$1;
	};

	const TUPLE = [0, 0, 0, 0];

	const Tuple = (minX, minY, maxX, maxY) => {
		TUPLE[0] = minX;
		TUPLE[1] = minY;
		TUPLE[2] = maxX;
		TUPLE[3] = maxY;

		return TUPLE;
	};

	var index$b = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Box: Tuple,
		Line: Tuple$4,
		Point: Tuple$1,
		Segment: Tuple$2,
		Vector: Tuple$3
	});

	const translate$1 = (pointX, pointY, deltaX, deltaY) =>
		Tuple$1(pointX + deltaX, pointY + deltaY);

	const fromBothPoint = (fromX, fromY, toX, toY) =>
		Tuple$3(toX - fromX, toY - fromY);

	const fromSegment$2 = fromBothPoint;
	const from = fromBothPoint;

	/**
	 * @param {number} aX
	 * @param {number} aY
	 * @param {number} bX
	 * @param {number} bY
	 */
	const dot = (aX, aY, bX, bY) => aX * bX + aY * bY;

	/**
	 * @param {number} x
	 * @param {number} y
	 * @param {number} scalar
	 */
	const multiply = (x, y, scalar) => Tuple$3(x * scalar, y * scalar);

	/**
	 * @param {number} sourceX
	 * @param {number} sourceY
	 * @param {number} targetX
	 * @param {number} targetY
	 */
	const cross = (sourceX, sourceY, targetX, targetY) => {
		return sourceX * targetY - sourceY * targetX;
	};

	/**
	 * throw new Error(message)
	 * @function
	 * @param {string} message
	 * @param {function} ErrorType Error constructor
	 */
	const throwError = (message, ErrorType = Error) => {
		throw new ErrorType(message);
	};

	/**
	 * determines whether a operand is null or not
	 * @function
	 * @param {any} operand
	 * @returns {boolean}
	 */
	const isNull = operand => operand === null;

	/**
	 * determines whether a operand is not null
	 * @function
	 * @param {any} operand
	 * @returns {boolean}
	 */
	const isNotNull = operand => !isNull(operand);

	const MATH = Math;

	const abs = MATH.abs;
	const cos = MATH.cos;
	const max = MATH.max;
	const min = MATH.min;
	const sin = MATH.sin;
	const sqrt = MATH.sqrt;

	const length = (x, y) => sqrt(dot(x, y, x, y));

	/**
	 * @param {number} x
	 * @param {number} y
	 */
	const rotate90 = (x, y) => Tuple$3(-y, x);

	/**
	 * @param {number} x
	 * @param {number} y
	 */
	const normalize = (x, y) => {
		const result = length(x, y);

		if (result === 0) {
			throwError('Zero Vector CAN NOT be normalized.');
		}

		return Tuple$3(x / result, y / result);
	};

	const invert = (x, y) => Tuple$3(-x, -y);

	const rotate$1 = (x, y, angle) => {
		const cos$1 = cos(angle);
		const sin$1 = sin(angle);

		return Tuple$3(x * cos$1 - y * sin$1, x * sin$1 + y * cos$1);
	};

	const project$1 = (sourceX, sourceY, targetX, targetY) => {
		const normal = normalize(targetX, targetY);

		return multiply(...normal, dot(sourceX, sourceY, ...normal));
	};

	/**
	 * Floating point comparison tolerance.
	 * Default value is 0.000001 (10e-6)
	 *
	 * @type {number}
	 */
	let TOLERANCE = 0.000001;

	/**
	 * @param {number} tolerance
	 */
	const setTolerance = tolerance => {
		TOLERANCE = tolerance;
	};

	/**
	 * @param {number} x
	 */
	const EQ_0 = x => x < TOLERANCE && x > -TOLERANCE;

	/**
	 * @param {number} x
	 * @param {number} y
	 */
	const EQ = (x, y) => {
		const value = x - y;

		return (value < TOLERANCE && value > -TOLERANCE);
	};

	/**
	 * @param {number} x
	 * @param {number} y
	 */
	const GT = (x, y) => x - y > TOLERANCE;

	/**
	 * @param {number} x
	 * @param {number} y
	 */
	const GE = (x, y) => x - y > -TOLERANCE;

	/**
	 * @param {number} x
	 * @param {number} y
	 */
	const LT = (x, y) => x - y < -TOLERANCE;

	/**
	 * @param {number} x
	 * @param {number} y
	 */
	const LE = (x, y) => x - y < TOLERANCE;

	var index$a = /*#__PURE__*/Object.freeze({
		__proto__: null,
		EQ: EQ,
		EQ_0: EQ_0,
		GE: GE,
		GT: GT,
		LE: LE,
		LT: LT,
		setTolerance: setTolerance
	});

	const equal$1 = (aX, aY, bX, bY) => {
		return EQ(aX, bX) && EQ(aY, bY);
	};

	var index$9 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		cross: cross,
		dot: dot,
		equal: equal$1,
		from: from,
		fromBothPoint: fromBothPoint,
		fromSegment: fromSegment$2,
		invert: invert,
		length: length,
		multiply: multiply,
		normalize: normalize,
		project: project$1,
		rotate: rotate$1,
		rotate90: rotate90
	});

	const toLeftOfSegment = (pointX, pointy, fromX, fromY, toX, toY) => {
		return GT(cross(
			...fromBothPoint(fromX, fromY, toX, toY),
			...fromBothPoint(toX, toY, pointX, pointy)
		), 0);
	};

	const rotate = (pointX, pointY, angle, centerX = 0, centerY = 0) => {
		const vector = fromBothPoint(centerX, centerY, pointX, pointY);

		return translate$1(...rotate$1(...vector, angle), centerX, centerY);
	};

	const project = (pointX, pointY, anchorX, anchorY, normalX, normalY) => {
		if (equal(pointX, pointY, anchorX, anchorY)) {
			return Tuple$1(pointX, pointY);
		}

		const vector = fromBothPoint(pointX, pointY, anchorX, anchorY);

		if (EQ_0(cross(...vector, normalX, normalY))) {
			return Tuple$1(anchorX, anchorY);
		}

		return translate$1(pointX, pointY, ...project$1(...vector, normalX, normalY));
	};

	const distanceToPoint = (fromX, fromY, toX, toY) => {
		return length(...fromBothPoint(fromX, fromY, toX, toY));
	};

	const distanceToLine = (pointX, pointY, ...line) =>
		distanceToPoint(pointX, pointY, ...project(pointX, pointY, ...line));

	const equal = (aX, aY, bX, bY) => {
		return EQ(aX, bX) && EQ(aY, bY);
	};

	const distanceToSegment = (pointX, pointY, fromX, fromY, toX, toY) => {
		if (equal(fromX, fromY, toX, toY)) {
			return distanceToPoint(pointX, pointY, fromX, fromY);
		}

		const segmentVector = [...from(fromX, fromY, toX, toY)];
		const from2PointVector = [...from(fromX, fromY, pointX, pointY)];
		const to2PointVector = [...from(toX, toY, pointX, pointY)];

		const fromDotSegment = dot(...segmentVector, ...from2PointVector);
		const toDotSegment = -dot(...segmentVector, ...to2PointVector);

		if (GE(fromDotSegment, 0) && GE(toDotSegment, 0)) {
			const segmentUnitVector = [...normalize(...segmentVector)];

			const distance = abs(cross(...segmentUnitVector, ...from2PointVector));
			// const closestPoint = [...translate(fromX, fromY, ...Vector.multiply(
			// 	...segmentUnitVector,
			// 	Vector.dot(...segmentUnitVector, ...from2PointVector)
			// ))];

			// return [distance, [pointX, pointY, ...closestPoint]];
			return distance;
		} else if (fromDotSegment < 0) {
			return distanceToPoint(pointX, pointY, fromX, fromY);
		} else {
			return distanceToPoint(pointX, pointY, toX, toY);
		}
	};

	var index$8 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		distanceToLine: distanceToLine,
		distanceToPoint: distanceToPoint,
		distanceToSegment: distanceToSegment,
		equal: equal,
		project: project,
		rotate: rotate,
		toLeftOfSegment: toLeftOfSegment,
		translate: translate$1
	});

	/**
	 * @param {number} source
	 * @param {number} target
	 * @param {boolean} clockwise
	 */
	const differ = (source, target, clockwise = true) => {
		const delta = (clockwise ? 1 : -1) * (source - target);

		return delta >= 0 ? delta : delta + ROUND;
	};

	// export { normalize } from './normalize.js';

	var index$7 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		differ: differ
	});

	const fromSegment$1 = (fromX, fromY, toX, toY) => {
		const vector = fromSegment$2(fromX, fromY, toX, toY);
		const normal = rotate90(...normalize(...vector));
		const dot$1 = dot(...normal, fromX, fromY);
		const finalNormal = LT(dot$1, 0) ? normal : invert(...normal);

		return Tuple$4(fromX, fromY, ...finalNormal);
	};

	const STANDARD = [0, 0, 0];
	const A = 0, B = 1, C = 2;

	/**
	 * @param {number} x
	 * @param {number} y
	 * @param {number} vectorX
	 * @param {number} vectorY
	 */
	const toStandard = (x, y, vectorX, vectorY) => {
		STANDARD[A] = vectorX;
		STANDARD[B] = vectorY;
		STANDARD[C] = dot(vectorX, vectorY, x, y);

		return STANDARD;
	};

	const intersectLine = (x1, y1, vx1, vy1, x2, y2, vx2, vy2) => {
		const [a1, b1, c1] = toStandard(x1, y1, vx1, vy1);
		const [a2, b2, c2] = toStandard(x2, y2, vx2, vy2);

		const delta = a1 * b2 - b1 * a2;
		const deltaX = c1 * b2 - b1 * c2;
		const deltaY = a1 * c2 - c1 * a2;

		if (EQ_0(delta)) {
			return null;
		}

		if (EQ_0(b1)) {
			return Tuple$1(c1 / a1, deltaY / delta);
		}

		if (EQ_0(b2)) {
			return Tuple$1(c2 / a2, deltaY / delta);
		}

		if (EQ_0(a1)) {
			return Tuple$1(deltaX / delta, c1 / b1);
		}

		if (EQ_0(a2)) {
			return Tuple$1(deltaX / delta, c2 / b2);
		}

		return Tuple$1(deltaX / delta, deltaY / delta);
	};

	const containsPoint$2 = (x, y, vx, vy, px, py) => {
		if (equal(x, y, px, py)) {
			return true;
		}

		const vector = [...from(x, y, px, py)];

		return EQ_0(dot(vx, vy, ...vector));
	};

	const parallelToLine = (x1, y1, vx1, vy1, x2, y2, vx2, vy2) => {
		return EQ_0(cross(vx1, vy1, vx2, vy2));
	};

	const incidentToLine = (x1, y1, vx1, vy1, x2, y2, vx2, vy2) => {
		return parallelToLine(x1, y1, vx1, vy1, x2, y2, vx2, vy2)
			&& containsPoint$2(x2, y2, vx2, vy2, x1, y1);
	};

	var index$6 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		containsPoint: containsPoint$2,
		fromSegment: fromSegment$1,
		incidentToLine: incidentToLine,
		intersectLine: intersectLine,
		parallelToLine: parallelToLine,
		toStandard: toStandard
	});

	/**
	 * Computing a triangle area by 3 points a, b, c.
	 *
	 * @param {number} aX
	 * @param {number} aY
	 * @param {number} bX
	 * @param {number} bY
	 * @param {number} cX
	 * @param {number} cY
	 * @returns
	 */
	const doubleTriangleArea = (aX, aY, bX, bY, cX, cY) => {
		return (aX - cX) * (bY - cY) - (aY - cY) * (bX - cX);
	};

	/**
	 * @param {number} aFromX
	 * @param {number} aFromY
	 * @param {number} aToX
	 * @param {number} aToY
	 * @param {number} bFromX
	 * @param {number} bFromY
	 * @param {number} bToX
	 * @param {number} bToY
	 */
	const intersectSegmentOpen = (
		aFromX, aFromY, aToX, aToY, bFromX, bFromY, bToX, bToY
	) => {
		const abcArea = doubleTriangleArea(aFromX, aFromY, aToX, aToY, bFromX, bFromY);
		const abdArea = doubleTriangleArea(aFromX, aFromY, aToX, aToY, bToX, bToY);

		if (GE(abcArea * abdArea, 0)) {
			return null;
		}

		const cdaArea = doubleTriangleArea(bFromX, bFromY, bToX, bToY, aFromX, aFromY);
		const cdbArea = cdaArea + abcArea - abdArea;

		if (GE(cdaArea * cdbArea, 0)) {
			return null;
		}

		const fraction = cdaArea / (abdArea - abcArea);

		return Tuple$1(
			aFromX + fraction * (aToX - aFromX),
			aFromY + fraction * (aToY - aFromY)
		);
	};

	/**
	 * @param {number} fromX
	 * @param {number} fromY
	 * @param {number} toX
	 * @param {number} toY
	 * @param {number} vectorX
	 * @param {number} vectorY
	 */
	const translate = (fromX, fromY, toX, toY, vectorX, vectorY) =>
		Tuple$2(fromX + vectorX, fromY + vectorY, toX + vectorX, toY + vectorY);

	const middle = (fromX, fromY, toX, toY) =>
		Tuple$1((fromX + toX) / 2, (fromY + toY) / 2);

	const containsPoint$1 = (fromX, fromY, toX, toY, x, y) => {
		return EQ_0(distanceToSegment(x, y, fromX, fromY, toX, toY));
	};

	const isZeroLength = (fromX, fromY, toX, toY) => {
		return equal(fromX, fromY, toX, toY);
	};

	const fromSegment = (fromX, fromY, toX, toY) => {
		return Tuple(
			min(fromX, toX),
			min(fromY, toY),
			max(fromX, toX),
			max(fromY, toY)
		);
	};

	const notIntersect = (
		minX1, minY1, maxX1, maxY1, minX2, minY2, maxX2, maxY2
	) => {
		return (
			maxX1 < minX2 ||
			minX1 > maxX2 ||
			maxY1 < minY2 ||
			minY1 > maxY2
		);
	};

	var index$5 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		fromSegment: fromSegment,
		notIntersect: notIntersect
	});

	const intersectSegment = (aFromX, aFromY, aToX, aToY, bFromX, bFromY, bToX, bToY) => {
		const intersectPoint = [];

		const aBox = [...fromSegment(aFromX, aFromY, aToX, aToY)];
		const bBox = [...fromSegment(bFromX, bFromY, bToX, bToY)];

		if (notIntersect(...aBox, ...bBox)) {
			return intersectPoint;
		}

		if (isZeroLength(aFromX, aFromY, aToX, aToY)) {
			if (containsPoint$1(bFromX, bFromY, bToX, bToY, aFromX, aFromY)) {
				intersectPoint.push([aFromX, aFromY]);
			}

			return intersectPoint;
		}

		if (isZeroLength(bFromX, bFromY, bToX, bToY)) {
			if (containsPoint$1(aFromX, aFromY, aToX, aToY, bFromX, bFromY)) {
				intersectPoint.push([bFromX, bFromY]);
			}

			return intersectPoint;
		}

		const aLine = [...fromSegment$1(aFromX, aFromY, aToX, aToY)];
		const bLine = [...fromSegment$1(bFromX, bFromY, bToX, bToY)];

		if (incidentToLine(...aLine, ...bLine)) {
			if (containsPoint$1(bFromX, bFromY, bToX, bToY, aFromX, aFromY)) {
				intersectPoint.push([aFromX, aFromY]);
			}

			if (containsPoint$1(bFromX, bFromY, bToX, bToY, aToX, aToY)) {
				intersectPoint.push([aToX, aToY]);
			}

			if (containsPoint$1(aFromX, aFromY, aToX, aToY, bFromX, bFromY)
				&& !equal(bFromX, bFromY, aFromX, aFromY)
				&& !equal(bFromX, bFromY, aToX, aToY)) {

				intersectPoint.push([bFromX, bFromY]);
			}

			if (containsPoint$1(aFromX, aFromY, aToX, aToY, bToX, bToY)
				&& !equal(bToX, bToY, aFromX, aFromY)
				&& !equal(bToX, bToY, aToX, aToY)) {

				intersectPoint.push([bToX, bToY]);
			}
		} else {
			const lineIntersectPoint = intersectLine(...aLine, ...bLine);

			if (isNotNull(lineIntersectPoint)
				&& containsPoint$1(aFromX, aFromY, aToX, aToY, ...lineIntersectPoint)
				&& containsPoint$1(bFromX, bFromY, bToX, bToY, ...lineIntersectPoint)) {

				intersectPoint.push([...lineIntersectPoint]);
			}
		}

		return intersectPoint;
	};

	var index$4 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		containsPoint: containsPoint$1,
		intersectSegment: intersectSegment,
		intersectSegmentOpen: intersectSegmentOpen,
		isZeroLength: isZeroLength,
		middle: middle,
		translate: translate
	});

	const containsPoint = (polygonPointList, point) => {
		let inside = false;

		// use some raycasting to test hits
		// https://github.com/substack/point-in-polygon/blob/master/index.js
		// http://pixijs.download/release/docs/packages_math_src_shapes_Polygon.ts.html
		const length = polygonPointList.length;

		for (let i = 0, j = length - 1; i < length; j = i++) {
			const pI = polygonPointList[i];
			const pJ = polygonPointList[j];

			const intersect =
				(pI.y > point.y) !== (pJ.y > point.y) &&
				(point.x < (point.y - pI.y) / (pJ.y - pI.y) * (pJ.x - pI.x) + pI.x);

			if (intersect) {
				inside = !inside;
			}
		}

		return inside;
	};

	const area = (...axes) => {
		const length = axes.length / 2;
		let doubleArea = 0;

		for (let index = 0; index < length; index++) {
			const next = (index + 1) % length;

			doubleArea += cross(
				axes[2 * index],
				axes[2 * index + 1],
				axes[2 * next],
				axes[2 * next + 1]
			);
		}

		return doubleArea / 2;
	};

	var index$3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		area: area,
		containsPoint: containsPoint
	});

	class Vertex {
		constructor(x, y) {
			this.x = x;
			this.y = y;
			this.incidentEdge = null;
		}
	}

	class HalfEdge {
		constructor() {
			this.origin = null;
			this.twin = null;
			this.incidentFace = null;
			this.next = null;
			this.previous = null;
		}
	}

	class Face {
		constructor() {
			this.outerComponent = null;
			this.innerComponents = [];
		}
	}

	var index$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Face: Face,
		HalfEdge: HalfEdge,
		Vertex: Vertex
	});

	const MAX_SAFE_ITERATION_LENGTH = 9999;

	/**
	 * @param {import('../Struct').Vertex} vertex
	 */
	function *allHalfEdgeOfVertex(vertex) {
		const { incidentEdge } = vertex;

		if (isNotNull(incidentEdge)) {
			let current = incidentEdge, index = 0;

			do {
				yield current;

				current = current.twin.next;
				index++;
			} while (current !== incidentEdge && index < MAX_SAFE_ITERATION_LENGTH);
		}
	}

	/**
	 * @param {import('../Struct').HalfEdge} halfEdge
	 */
	function *allHalfEdgeOfPath(halfEdge) {
		let current = halfEdge, index = 0;

		do {
			yield current;

			current = current.next;
			index++;
		} while (current !== halfEdge && index < MAX_SAFE_ITERATION_LENGTH);
	}

	var index$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		allHalfEdgeOfPath: allHalfEdgeOfPath,
		allHalfEdgeOfVertex: allHalfEdgeOfVertex
	});

	/**
	 * @param {number} x
	 * @param {number} y
	 */
	const createVertex = (x = 0, y = 0) => new Vertex(x, y);

	/**
	 * @param {import('./Struct').Vertex} vertex
	 */
	const getVertexHalfEdgeList = vertex => {
		const list = [];

		for (const halfEdge of allHalfEdgeOfVertex(vertex)) {
			list.push(halfEdge);
		}

		return list;
	};

	/**
	 * @param {import('./Struct').Vertex} vertex
	 */
	const hasNoHalfEdge = vertex => isNull(vertex.incidentEdge);

	/**
	 * @param {import('./Struct').Vertex} vertex
	 */
	const hasOnlyHalfEdge = vertex => {
		return hasNoHalfEdge(vertex)
			? false
			: vertex.incidentEdge === vertex.incidentEdge.twin.next;
	};

	/**
	 * @param {import('./Struct').HalfEdge} halfEdge
	 */
	const getAngleOfHalfEdge = halfEdge => {
		const {
			x: fromX,
			y: fromY
		} = halfEdge.origin;

		const {
			x: toX,
			y: toY
		} = halfEdge.twin.origin;

		return Math.atan2(toY - fromY, toX - fromX);
	};

	/**
	 * @param {import('./Struct').HalfEdge} pathHalfEdge
	 * @param {import('./Struct').HalfEdge} targetHalfEdge
	 */
	const isPathContainsHalfEdge = (pathHalfEdge, targetHalfEdge) => {
		for (const current of allHalfEdgeOfPath(pathHalfEdge)) {
			if (current === targetHalfEdge) {
				return true;
			}
		}

		return false;
	};

	/**
	 * @param {import('./Struct').HalfEdge} pathHalfEdge
	 * @param {import('./Struct').Vertex} targetVertex
	 */
	const isPathContainsVertex = (pathHalfEdge, targetVertex) => {
		for (const current of allHalfEdgeOfPath(pathHalfEdge)) {
			if (current.origin === targetVertex) {
				return true;
			}
		}

		return false;
	};

	/**
	 * @param {import('./Struct').HalfEdge} halfEdge
	 */
	const isTwinInSamePath = halfEdge => {
		return isPathContainsHalfEdge(halfEdge, halfEdge.twin);
	};

	/**
	 * @param {import('./Struct').HalfEdge} sourceHalfEdge
	 */
	const getPathOfHalfEdge = sourceHalfEdge => {
		const list = [];

		for (const halfEdge of allHalfEdgeOfPath(sourceHalfEdge)) {
			list.push(halfEdge);
		}

		return list;
	};

	/**
	 * @param {import('./Struct').HalfEdge} sourceHalfEdge
	 */
	const getBottomLeftOfPath = sourceHalfEdge => {
		let target = null, minX, minY, maxRatio = -Infinity;

		minX = minY = Number.MAX_SAFE_INTEGER;

		for (const halfEdge of allHalfEdgeOfPath(sourceHalfEdge)) {
			// Use `<=` for querying the later HalfEdge
			// There MAY be a pair of overlap HalfEdge in the polygon path.
			const { x: currentX, y: currentY } = halfEdge.origin;
			const { x: nextX, y: nextY } = halfEdge.next.origin;
			const ratio = (nextY - currentY) / (nextX - currentX);

			if (
				(currentX < minX) ||
				(currentX === minX && currentY < minY) ||
				(currentX === minX && currentY === minY && ratio > maxRatio)
			) {
				minX = currentX;
				minY = currentY;
				maxRatio = ratio;
				target = halfEdge;
			}
		}

		return target;
	};

	/**
	 * @param {import('./Struct').HalfEdge} halfEdge
	 */
	const isOuterPath = halfEdge => {
		const origin = getBottomLeftOfPath(halfEdge);
		const previousTwin = origin.previous.twin;

		/**
		 * If previous twin is origin, it MUST be a inner component though the angle
		 * of these two HalfEdge is 0.
		 */

		return previousTwin === origin
			? false
			: differ(getAngleOfHalfEdge(previousTwin), getAngleOfHalfEdge(origin)) < Math.PI;
	};

	/**
	 * @param {import('./Struct').HalfEdge} halfEdge
	 */
	const isInnerPath = halfEdge => !isOuterPath(halfEdge);

	/**
	 * @param {Struct.HalfEdge} halfEdge
	 * @param {Struct.Vertex} vertex
	 */
	const splitHalfEdgeByVertex = (halfEdge, vertex) => {
		const from = halfEdge;
		const to = from.twin;
		const newFrom = new HalfEdge();
		const newTo = new HalfEdge();

		// About origin
		vertex.incidentEdge = newFrom;
		newFrom.origin = newTo.origin = vertex;

		// About incidentFace
		newFrom.incidentFace = from.incidentFace;
		newTo.incidentFace = to.incidentFace;

		// About Twin
		newFrom.twin = to;
		to.twin = newFrom;
		newTo.twin = from;
		from.twin = newTo;

		// About next, previous
		const oldFromNext = from.next;
		const oldToNext = to.next;

		newFrom.next = oldFromNext;
		from.next = newFrom;
		newFrom.previous = from;
		oldFromNext.previous = newFrom;

		newTo.next = oldToNext;
		to.next = newTo;
		newTo.previous = to;
		oldToNext.previous = newTo;

		return newFrom;
	};

	const toOrigin = halfEdge => halfEdge.origin;

	/**
	 * @param {import('./Struct').Face} face
	 * @returns {import('./Struct').Vertex[]}
	 */
	const getPolygonFromFaceOuter = face => {
		const { outerComponent: outer } = face;

		return isNull(outer) ? [] : getPathOfHalfEdge(outer).map(toOrigin);
	};

	/**
	 * @param {import('./Struct').HalfEdge} halfEdge
	 */
	const handleDetectedHalfEdge = (halfEdge, faceList, newFaceList) => {
		const twinFace = halfEdge.twin.incidentFace;

		if (!faceList.includes(twinFace)) {
			faceList.push(twinFace);
			newFaceList.push(twinFace);
		}
	};

	/**
	 * @param {import('./Struct').Face} face
	 */
	const queryChildFaceList = face => {
		const list = [face];
		const newFaceList = [];

		for (const currentInner of face.innerComponents) {
			for (const currentHalfEdge of allHalfEdgeOfPath(currentInner)) {
				handleDetectedHalfEdge(currentHalfEdge, list, newFaceList);
			}

			while (newFaceList.length) {
				for (const currentFace of newFaceList.splice(0)) {
					for (const currentHalfEdge of allHalfEdgeOfPath(currentFace.outerComponent)) {
						handleDetectedHalfEdge(currentHalfEdge, list, newFaceList);
					}
				}
			}
		}

		list.shift();

		return list;
	};

	/**
	 * @param {import('./Struct').Face} face
	 * @param {import('../Struct').Point} point
	 * @returns {import('./Struct').Face | null}
	 */
	const getFaceOfPoint = (face, point) => {
		const isInOuterComponent = isNull(face.outerComponent) ? true
			: containsPoint(getPolygonFromFaceOuter(face), point);

		if (isInOuterComponent) {
			for (const childFace of queryChildFaceList(face)) {
				const target = getFaceOfPoint(childFace, point);

				if (isNotNull(target)) {
					return target;
				}
			}

			return face;
		}

		return null;
	};

	const createFace = () => new Face();

	// Struct

	var index = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Iterator: index$1,
		Struct: index$2,
		createGlobalFace: createFace,
		createVertex: createVertex,
		getAngleOfHalfEdge: getAngleOfHalfEdge,
		getFaceOfPoint: getFaceOfPoint,
		getPathOfHalfEdge: getPathOfHalfEdge,
		getPolygonFromFaceOuter: getPolygonFromFaceOuter,
		getVertexHalfEdgeList: getVertexHalfEdgeList,
		hasNoHalfEdge: hasNoHalfEdge,
		hasOnlyHalfEdge: hasOnlyHalfEdge,
		isInnerPath: isInnerPath,
		isOuterPath: isOuterPath,
		isPathContainsHalfEdge: isPathContainsHalfEdge,
		isPathContainsVertex: isPathContainsVertex,
		isTwinInSamePath: isTwinInSamePath,
		queryChildFaceList: queryChildFaceList,
		splitHalfEdgeByVertex: splitHalfEdgeByVertex
	});

	exports.Angle = index$7;
	exports.Box = index$5;
	exports.Comparator = index$a;
	exports.Constant = Constant;
	exports.DCEL = index;
	exports.Line = index$6;
	exports.Point = index$8;
	exports.Polygon = index$3;
	exports.Segment = index$4;
	exports.Tuple = index$b;
	exports.Vector = index$9;

}));
